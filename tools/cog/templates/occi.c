[[[cog import codegen.cog_common as t; t.init_models(model_dir, cog_category_file) ]]]
[[[end]]]
/* ---------------------------------------------------------------------------- */
/* Advanced Capabilities for Compatible One Resources Delivery System - ACCORDS	*/
/* (C) 2011 by Iain James Marshall <ijm667@hotmail.com>				*/
/* ---------------------------------------------------------------------------- */
/*										*/
/* This is free software; you can redistribute it and/or modify it		*/
/* under the terms of the GNU Lesser General Public License as			*/
/* published by the Free Software Foundation; either version 2.1 of		*/
/* the License, or (at your option) any later version.				*/
/*										*/
/* This software is distributed in the hope that it will be useful,		*/
/* but WITHOUT ANY WARRANTY; without even the implied warranty of		*/
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU		*/
/* Lesser General Public License for more details.				*/
/*										*/
/* You should have received a copy of the GNU Lesser General Public		*/
/* License along with this software; if not, write to the Free			*/
/* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA		*/
/* 02110-1301 USA, or see the FSF site: http://www.fsf.org.			*/
/*										*/
/* ---------------------------------------------------------------------------- */

/* WARNING: This file is generated by the build system.  Do not modify by hand */ 
#ifndef _occiFILENAME_ROOT_c_
#define _occiFILENAME_ROOT_c_

#include "standard.h"
#include "rest.h"
#include "occi.h"
#include "document.h"

#include "backend_common.h"
 
#include "FILENAME_ROOT_occi_filter.h"
#include "FILENAME_ROOT.h"
#include "FILENAME_ROOT_backend_interface.h"
[[[cog t.backend_include()]]]
[[[end]]]

#include "occi_rest_FILENAME_ROOT.h"

/*	--------------------------------------------	*/
/*	o c c i _ 
[[[cog t.split_category_name()]]]
[[[end]]] 
	*/
/*	--------------------------------------------	*/

struct FILENAME_ROOT_backend_interface * CATEGORY_NAME_backend;

private void CATEGORY_NAME_execute_callback(callback_func func, struct CATEGORY_NAME *target, struct occi_category * optr, struct rest_request * rptr) {
	if (func && target) {
		(*func)(optr,target,rptr);
	}
}


private struct rest_response *CATEGORY_NAME_bad_request_response(struct rest_response * aptr, char *id) {
	struct CATEGORY_NAME *target;
	if (!(target =  CATEGORY_NAME_backend->retrieve_from_id(id))) {
		return( not_found_html_response(aptr) );
	}
	else {
		liberate_CATEGORY_NAME(target);
		return( bad_request_html_response(aptr));
	}
}

/*	------------------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   a c t i v a t e   f i l t e r 	*/
/*	------------------------------------------------------------------------------------------------------	*/
private void activate_CATEGORY_NAME_filter_on_field(
	struct occi_category * cptr,void * target_void, char * field_name)
{
	struct CATEGORY_NAME_occi_filter * target;
	char prefix[1024];
	if (!( target = target_void )) return;
	sprintf(prefix,"%s.%s.",cptr->domain,cptr->id);
	if (!( strncmp( field_name, prefix, strlen(prefix) ) )) {
		field_name += strlen(prefix);
		[[[cog t.activate_filter()]]]
		[[[end]]]
		}
	return;
}

/*	------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   s e t   f i e l d 	*/
/*	------------------------------------------------------------------------------------------	*/
private void set_CATEGORY_NAME_field(
	struct occi_category * cptr,void * target_void, char * field_name, char * value)
{
	struct CATEGORY_NAME * pptr;
	char prefix[1024];
	if (!( pptr = target_void )) return;
	sprintf(prefix,"%s.%s.",cptr->domain,cptr->id);
	if (!( strncmp( field_name, prefix, strlen(prefix) ) )) {
		field_name += strlen(prefix);
		[[[cog t.set_field()]]]
		[[[end]]]
		}
	return;
}

/*	--------------------------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   s e t   f i l t e r   o n   f i e l d 	*/
/*	--------------------------------------------------------------------------------------------------------------	*/
private void set_CATEGORY_NAME_filter_on_field(
	struct occi_category * category, void * target_void, char * field_name, char * value)
{
	struct CATEGORY_NAME_occi_filter *filter = target_void;
	set_CATEGORY_NAME_field(category, filter->attributes, field_name, value);
	activate_CATEGORY_NAME_filter_on_field(category, filter, field_name);
}

/*	--------------------------------------------------	*/
/*	o c c i   c a t e g o r y   f i l t e r   i n f o 	*/
/*	--------------------------------------------------	*/
private int filter_CATEGORY_NAME_info(
	struct CATEGORY_NAME_occi_filter *filter,
	struct occi_category * optr,
	struct rest_request  * rptr,
	struct rest_response * aptr) {
	*filter = (const struct CATEGORY_NAME_occi_filter) {0};
	if (!( filter->attributes = allocate_CATEGORY_NAME()))
		return 0;
	else if (!( occi_process_atributs(optr, rptr, aptr, filter, set_CATEGORY_NAME_filter_on_field) )) {
		liberate_CATEGORY_NAME(filter->attributes);
		return 0;
	}
	else	return( 1 );
}

/*	----------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   r e s p o n s e 	*/
/*	----------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_occi_response(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr,
	struct CATEGORY_NAME * pptr)
{
	struct rest_header * hptr;
	sprintf(cptr->buffer,"occi.core.id=%c%s%c",0x0022,pptr->id,0x0022);
	if (!( hptr = rest_response_header( aptr, "X-OCCI-Attribute",cptr->buffer) ))
		return( rest_html_response( aptr, 500, "Server Failure" ) );
	[[[cog t.occi_response()]]]
	[[[end]]]
	if ( occi_render_links( aptr, pptr->id ) != 0)
		return( rest_html_response( aptr, 500, "Server Link Failure" ) );
	else	if (!( occi_success( aptr ) ))
		return( rest_response_status( aptr, 500, "Server Failure" ) );
	else	return( rest_response_status( aptr, 200, "OK" ) );
}

private struct rest_response* make_response_and_liberate_FILENAME_ROOT(
		struct occi_category* optr, struct rest_client* cptr,
		struct rest_request* rptr, struct rest_response* aptr,
		struct CATEGORY_NAME* target) {
	struct rest_response* retVal = CATEGORY_NAME_occi_response(optr, cptr, rptr, aptr, target);
	liberate_CATEGORY_NAME(target);
	return retVal;
}

/*	----------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   g e t   i t e m 	*/
/*	----------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_get_item(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr, char * id)
{
	struct rest_header * hptr;
	struct occi_interface * iptr;
	iptr = optr->callback;
	struct CATEGORY_NAME * FILENAME_ROOT;
	if (!( FILENAME_ROOT =  CATEGORY_NAME_backend->retrieve_from_id(id)))
		return( not_found_html_response(aptr) );
	if (iptr && iptr->pre_retrieve) {
		CATEGORY_NAME_execute_callback(iptr->pre_retrieve, FILENAME_ROOT, optr, rptr);
		CATEGORY_NAME_backend->update(id, FILENAME_ROOT);
	}
	return make_response_and_liberate_FILENAME_ROOT(optr, cptr, rptr, aptr, FILENAME_ROOT);
}

/*	------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   p o s t   l i n k 	*/
/*	------------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_post_link(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr,char * id)
{
	return (CATEGORY_NAME_bad_request_response(aptr, id));
}

[[[cog t.post_mixin_and_action()]]]
[[[end]]]
 
/*	------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   p o s t   i t e m 	*/
/*	------------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_post_item(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr)
{
	struct occi_interface * iptr;
	struct CATEGORY_NAME * initial_FILENAME_ROOT, *new_FILENAME_ROOT;
	char * reqhost;
	int    reqport=0;
	iptr = optr->callback;
	if (!( reqhost = rest_request_host( rptr ) ))
		return( rest_html_response( aptr, 400, "Bad Request" ) );
	else reqport = rptr->port;
	if (!( initial_FILENAME_ROOT = allocate_CATEGORY_NAME()))
		return( rest_html_response( aptr, 500, "Server Failure") );
	if (!( occi_process_atributs( optr, rptr,aptr, initial_FILENAME_ROOT, set_CATEGORY_NAME_field ) ))
		return( rest_html_response( aptr, 500, "Server Failure") );
	char *id = generate_id();
	if (!id) {
	    return( rest_html_response( aptr, 500, "Server Failure") );
	}
	initial_FILENAME_ROOT->id = id;
	if (iptr) {
		CATEGORY_NAME_execute_callback(iptr->pre_create, initial_FILENAME_ROOT, optr, rptr);
	}
	if (!( new_FILENAME_ROOT =  CATEGORY_NAME_backend->create(initial_FILENAME_ROOT))) {
		liberate_CATEGORY_NAME(initial_FILENAME_ROOT);
		return( rest_html_response( aptr, 500, "Server Failure") );
	}
	liberate_CATEGORY_NAME(initial_FILENAME_ROOT);
	if (iptr) {
        CATEGORY_NAME_execute_callback(iptr->post_create, new_FILENAME_ROOT, optr, rptr);
	}
	sprintf(cptr->buffer,"%s:%u%s%s",reqhost,reqport,optr->location,new_FILENAME_ROOT->id);
	liberate_CATEGORY_NAME(new_FILENAME_ROOT);
	if (!rest_response_header( aptr, "X-OCCI-Location",cptr->buffer))
		return( rest_html_response( aptr, 500, "Server Failure" ) );
	else if (!( occi_success( aptr ) ))
		return( rest_response_status( aptr, 500, "Server Failure" ) );
	else	return( rest_response_status( aptr, 200, "OK" ) );
}

/*	----------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   p u t   i t e m 	*/
/*	----------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_put_item(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr,char * id)
{
	struct rest_header * hptr;
	struct occi_interface * iptr;
	struct CATEGORY_NAME * FILENAME_ROOT;
	iptr = optr->callback;
	if (!( FILENAME_ROOT =  CATEGORY_NAME_backend->retrieve_from_id(id) ))
		return( not_found_html_response(aptr) );
	if (!( occi_process_atributs(optr,rptr,aptr, FILENAME_ROOT, set_CATEGORY_NAME_field ) )) {
	    liberate_CATEGORY_NAME(FILENAME_ROOT);
		return( rest_html_response( aptr, 500, "Server Failure") );
	}
	if (iptr) {	CATEGORY_NAME_execute_callback(iptr->pre_update, FILENAME_ROOT, optr, rptr); }
	CATEGORY_NAME_backend->update(id, FILENAME_ROOT);
	if (iptr) {	CATEGORY_NAME_execute_callback(iptr->post_update, FILENAME_ROOT, optr, rptr); }
	struct rest_response *retVal = CATEGORY_NAME_occi_response(optr, cptr, rptr, aptr, FILENAME_ROOT);
	liberate_CATEGORY_NAME(FILENAME_ROOT);
	return retVal;
}

/*	------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   h e a d   i t e m 	*/
/*	------------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_head_item(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr,char * id)
{
	CATEGORY_NAME_bad_request_response(aptr, id);
}

/*	----------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   d e l e t e   i t e m 	*/
/*	----------------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_delete_item(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr, char * id)
{
	struct rest_header * hptr;
	struct occi_interface * iptr;
	struct CATEGORY_NAME * pptr;
	iptr = optr->callback;
	struct CATEGORY_NAME *target;
	if (!( target =  CATEGORY_NAME_backend->retrieve_from_id(id)))
		return( not_found_html_response(aptr) );
	if (iptr) {	CATEGORY_NAME_execute_callback(iptr->pre_delete, target, optr, rptr); }
	liberate_CATEGORY_NAME(target);
	CATEGORY_NAME_backend->del(id);
	if (iptr) {	CATEGORY_NAME_execute_callback(iptr->post_delete, NULL, optr, rptr); }
	if (!( occi_success( aptr ) ))
		return( rest_response_status( aptr, 500, "Server Failure" ) );
	else	return( rest_response_status( aptr, 200, "OK" ) );
}

/*	----------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   g e t   l i s t 	*/
/*	----------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_get_list(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr)
{
	struct rest_header * hptr;
	struct CATEGORY_NAME_occi_filter filter;
	char * reqhost;
	int reqport=0;
	if (!( reqhost = rest_request_host( rptr ) ))
		return( rest_html_response( aptr, 400, "Bad Request" ) );
	else reqport = rptr->port;
	if (!( filter_CATEGORY_NAME_info(&filter, optr, rptr, aptr ) ))
		return( rest_html_response( aptr, 400, "Bad Request" ) );
	CATEGORY_NAME_id_list ids =  CATEGORY_NAME_backend->list(&filter);
	int id;
	int failed = 0;
	for(id = 0; id < ids.count; id++) {
		sprintf(cptr->buffer,"%s:%u%s%s",reqhost,reqport,optr->location,ids.ids[id]);
		if (!( hptr = rest_response_header( aptr, "X-OCCI-Location",cptr->buffer) ))
			failed = 1;
	}	
	CATEGORY_NAME_free_id_list(&ids);
	liberate_CATEGORY_NAME(filter.attributes);
	if(failed) {
		return (rest_html_response( aptr, 500, "Server Failure" ));
	}
	if (!( occi_success( aptr ) ))
		return( rest_response_status( aptr, 500, "Server Failure" ) );
	else	return( rest_response_status( aptr, 200, "OK" ) );
}


/*	--------------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   d e l e t e   a l l 	*/
/*	--------------------------------------------------------------------------------------------	*/
private struct rest_response * CATEGORY_NAME_delete_all(
	struct occi_category * optr, struct rest_client * cptr,
	struct rest_request * rptr, struct rest_response * aptr)
{
	struct occi_interface * iptr;
	struct CATEGORY_NAME_occi_filter filter;
	iptr = optr->callback;
	if (!( filter_CATEGORY_NAME_info(&filter, optr, rptr, aptr ) ))
		return( rest_html_response( aptr, 400, "Bad Request" ) );
	CATEGORY_NAME_list item_list = CATEGORY_NAME_backend->retrieve_from_filter(&filter);
	int index;
	for(index = 0; index < item_list.count; index++) {
		if (iptr) {	CATEGORY_NAME_execute_callback(iptr->pre_delete, item_list.FILENAME_ROOTs[index], optr, rptr); }
	}
	free_CATEGORY_NAME_list(&item_list);
	CATEGORY_NAME_backend->delete_all_matching_filter(&filter);
	liberate_CATEGORY_NAME(filter.attributes);
	if (!( occi_success( aptr ) ))
		return( rest_response_status( aptr, 500, "Server Failure" ) );
	else	return( rest_response_status( aptr, 200, "OK" ) );
}

/*	------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   g e t 	*/
/*	------------------------------------------------------------------------------	*/
private struct rest_response * occi_CATEGORY_NAME_get(void * vptr, struct rest_client * cptr, struct rest_request * rptr)
{
	struct rest_response * aptr;
	struct rest_header   * hptr;
	struct occi_category * optr;
	char * ctptr;
	char * mptr;
	if (!( hptr = rest_resolve_header( rptr->first, "Content-Type" ) ))
		ctptr = "text/occi";
	else	ctptr = hptr->value;
	if (!( optr = vptr )) 
		return( rest_bad_request(vptr,cptr,rptr) );
	if(!(aptr = rest_allocate_response( cptr )))
		return( aptr );
	else if (!(strcmp( rptr->object, optr->location ) ))
		return( CATEGORY_NAME_get_list( optr, cptr, rptr, aptr ) );
	else if (!(strncmp( rptr->object, optr->location, strlen(optr->location) ) ))
		return( CATEGORY_NAME_get_item( optr, cptr, rptr, aptr,rptr->object+strlen(optr->location) ) );
	else	return( bad_request_html_response(aptr) );
}

/*	--------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   h e a d 	*/
/*	--------------------------------------------------------------------------------	*/
private struct rest_response * occi_CATEGORY_NAME_head(void * vptr, struct rest_client * cptr, struct rest_request * rptr)
{
	struct rest_response * aptr;
	struct rest_header   * hptr;
	struct occi_category * optr;
	char * ctptr;
	char * mptr;
	if (!( hptr = rest_resolve_header( rptr->first, "Content-Type" ) ))
		ctptr = "text/occi";
	else	ctptr = hptr->value;
	if (!( optr = vptr )) 
		return( rest_bad_request(vptr,cptr,rptr) );
	if(!(aptr = rest_allocate_response( cptr )))
		return( aptr );
	else if (!(strncmp( rptr->object, optr->location, strlen(optr->location) ) ))
		return( CATEGORY_NAME_head_item( optr, cptr, rptr, aptr,rptr->object+strlen(optr->location) ) );
	else	return( bad_request_html_response(aptr) );
}

/*	--------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   p o s t 	*/
/*	--------------------------------------------------------------------------------	*/
private struct rest_response * occi_CATEGORY_NAME_post(void * vptr, struct rest_client * cptr, struct rest_request * rptr)
{
	struct rest_response * aptr;
	struct rest_header   * hptr;
	struct occi_category * optr;
	char * ctptr;
	char * mptr;
	if (!( hptr = rest_resolve_header( rptr->first, "Content-Type" ) ))
		ctptr = "text/occi";
	else	ctptr = hptr->value;
	if (!( optr = vptr )) 
		return( rest_bad_request(vptr,cptr,rptr) );
	if(!(aptr = rest_allocate_response( cptr )))
		return( aptr );
	else if (!( strcmp( rptr->object, optr->location ) ))
		return( CATEGORY_NAME_post_item( optr, cptr, rptr, aptr ) );
	else if ( strncmp( rptr->object, optr->location,strlen(optr->location)) != 0)
		return( bad_request_html_response(aptr) );
	else if (!( rptr->parameters ))
		return( bad_request_html_response(aptr) );
	[[[cog t.post_actions()]]]
	[[[end]]]
	else	return( bad_request_html_response(aptr) );
}

/*	------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   p u t 	*/
/*	------------------------------------------------------------------------------	*/
private struct rest_response * occi_CATEGORY_NAME_put(void * vptr, struct rest_client * cptr, struct rest_request * rptr)
{
	struct rest_response * aptr;
	struct rest_header   * hptr;
	struct occi_category * optr;
	char * ctptr;
	char * mptr;
	if (!( hptr = rest_resolve_header( rptr->first, "Content-Type" ) ))
		ctptr = "text/occi";
	else	ctptr = hptr->value;
	if (!( optr = vptr )) 
		return( rest_bad_request(vptr,cptr,rptr) );
	if(!(aptr = rest_allocate_response( cptr )))
		return( aptr );
	else if (!(strncmp( rptr->object, optr->location, strlen(optr->location) ) ))
		return( CATEGORY_NAME_put_item( optr, cptr, rptr, aptr,rptr->object+strlen(optr->location) ) );
	else	return( bad_request_html_response(aptr) );
}

/*	------------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   m e t h o d   d e l e t e 	*/
/*	------------------------------------------------------------------------------------	*/
private struct rest_response * occi_CATEGORY_NAME_delete(void * vptr, struct rest_client * cptr, struct rest_request * rptr)
{
	struct rest_response * aptr;
	struct rest_header   * hptr;
	struct occi_category * optr;
	char * ctptr;
	char * mptr;
	if (!( hptr = rest_resolve_header( rptr->first, "Content-Type" ) ))
		ctptr = "text/occi";
	else	ctptr = hptr->value;
	if (!( optr = vptr )) 
		return( rest_bad_request(vptr,cptr,rptr) );
	if(!(aptr = rest_allocate_response( cptr )))
		return( aptr );
	else if (!(strcmp( rptr->object, optr->location ) ))
		return( CATEGORY_NAME_delete_all( optr, cptr, rptr, aptr ) );
	else if (!(strncmp( rptr->object, optr->location, strlen(optr->location) ) ))
		return( CATEGORY_NAME_delete_item( optr, cptr, rptr, aptr,rptr->object+strlen(optr->location) ) );
	else	return( bad_request_html_response(aptr) );
}

/*	--------------------------------------------------------------------------------	*/
/*	o c c i   c a t e g o r y   r e s t   i n t e r f a c e   r e d i r e c t i o n 	*/
/*	--------------------------------------------------------------------------------	*/
private void	redirect_occi_CATEGORY_NAME_mt( struct rest_interface * iptr )
{
	iptr->get = occi_CATEGORY_NAME_get;
	iptr->post = occi_CATEGORY_NAME_post;
	iptr->put = occi_CATEGORY_NAME_put;
	iptr->delete = occi_CATEGORY_NAME_delete;
	iptr->head = occi_CATEGORY_NAME_head;
	return;
}

[[[cog t.crud_delete_action()]]]
[[[end]]]

/*	------------------------------------------	*/
/*	o c c i   c a t e g o r y   b u i l d e r 	*/
/*	------------------------------------------	*/
/* occi category rest instance builder for : occi_CATEGORY_NAME */
public struct occi_category * occi_CATEGORY_NAME_builder(char * a,char * b) {
	char * c="http://scheme.compatibleone.fr/scheme/compatible#";
	char * d="
[[[cog t.node_type()]]]
[[[end]]] 
";
	char * e="http://scheme.ogf.org/occi/
[[[cog t.scheme_kind()]]]
[[[end]]]
#";
	char * f="CompatibleOne OCCI resource CATEGORY_NAME";
	[[[cog t.backend_init()]]]
	[[[end]]]
	struct occi_category * optr;
	if (!( optr = occi_create_category(a,b,c,d,e,f) )) { return(optr); }
	else {
		redirect_occi_CATEGORY_NAME_mt(optr->interface);
		[[[cog t.occi_builder()]]]
		[[[end]]]
		 CATEGORY_NAME_backend->init();
		return(optr);
	}

}

/*	------------------------------------------------------------	*/
/*	
[[[cog t.split_category_name()]]]
[[[end]]] 
_ o c c i _ h e a d e r s 	*/
/*	------------------------------------------------------------	*/
public struct rest_header *  CATEGORY_NAME_occi_headers(struct CATEGORY_NAME * sptr)
{
	struct rest_header * first=(struct rest_header *) 0;
	struct rest_header * last=(struct rest_header *) 0;
	struct rest_header * hptr=(struct rest_header *) 0;
	char buffer[8192];
	if (!( sptr )) return(0);
	if (!( hptr = allocate_rest_header()))
		return(hptr);
		else	if (!( hptr->previous = last))
			first = hptr;
		else	hptr->previous->next = hptr;
		last = hptr;
	if (!( hptr->name = allocate_string("Category")))
		return(first);
	sprintf(buffer,"CATEGORY_NAME; scheme='http://scheme.compatibleone.fr/scheme/compatible#'; class='kind';\r\n");
	if (!( hptr->value = allocate_string(buffer)))
		return(first);
	[[[cog t.occi_headers()]]]
	[[[end]]]
	return(first);

}

#endif	/* _occiFILENAME_ROOT_c_ */
